<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Committer基本能力考试</title>
    <link href="/2023/01/10/Committer%E5%9F%BA%E6%9C%AC%E8%83%BD%E5%8A%9B%E8%80%83%E8%AF%95/"/>
    <url>/2023/01/10/Committer%E5%9F%BA%E6%9C%AC%E8%83%BD%E5%8A%9B%E8%80%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Committer基本能力考试-2023年1月"><a href="#Committer基本能力考试-2023年1月" class="headerlink" title="Committer基本能力考试 2023年1月"></a>Committer基本能力考试 2023年1月</h1><blockquote><p>第一次考试84分，未通过，在此记录所有考试题及试题解析。</p><p>本次考试涉及知识模块：</p><ol><li>华为CleanCode</li><li>华为Java编码规范</li><li>产品安全红线</li><li>坏味道与重构</li></ol></blockquote><h2 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h2><ul><li>做参数校验时，在一般情况下优先使用“黑名单”校验，即拒绝已知的坏的数据。<ul><li><input disabled="" type="checkbox"> 正确</li><li><input checked="" disabled="" type="checkbox"> 错误</li></ul></li><li>过大的类的重构方法主要包括：提取类、提取子类、提取接口&#x2F;超类<ul><li><input checked="" disabled="" type="checkbox"> 正确</li><li><input disabled="" type="checkbox"> 错误</li></ul></li><li>可在finally语句块中出现控制流语句<ul><li><input disabled="" type="checkbox"> 正确</li><li><input checked="" disabled="" type="checkbox"> 错误</li></ul></li><li>禁止将mutable（可变）对象定义为常量<ul><li><input checked="" disabled="" type="checkbox"> 正确</li><li><input disabled="" type="checkbox"> 错误</li></ul></li><li>直接捕获基类异常Exception可以减少代码量，方便以后维护<ul><li><input disabled="" type="checkbox"> 正确</li><li><input checked="" disabled="" type="checkbox"> 错误</li></ul></li><li>消除重复Switch的主要方法是以多态取代条件表达式<ul><li><input checked="" disabled="" type="checkbox"> 正确</li><li><input disabled="" type="checkbox"> 错误</li></ul></li><li>File.getAbsolutePath()可正确对文件路径进行标准化处理，也可以使用getCanonicalPath()<ul><li><input disabled="" type="checkbox"> 正确</li><li><input checked="" disabled="" type="checkbox"> 错误</li></ul></li><li>数字字面量应该设置合适的后缀，long类型应该使用L作为后缀<ul><li><input checked="" disabled="" type="checkbox"> 正确</li><li><input disabled="" type="checkbox"> 错误</li></ul></li><li>我们应当消除代码中所有的注释，变存在注释的坏味道<ul><li><input disabled="" type="checkbox"> 正确</li><li><input checked="" disabled="" type="checkbox"> 错误</li></ul></li><li>java.util.Random类不能用于安全敏感应用或者敏感数据保护。应使用更加安全的随机数生成器，例如java.security.SecureRandom类<ul><li><input checked="" disabled="" type="checkbox"> 正确</li><li><input disabled="" type="checkbox"> 错误</li></ul></li><li>基本类型偏执容易暴露较多细节，代码内聚性差，可读性差<ul><li><input checked="" disabled="" type="checkbox"> 正确</li><li><input disabled="" type="checkbox"> 错误</li></ul></li><li>除法运算或取模运算，当除数为0时，会抛出异常，所以在进行这些运算时，无需提前判断除数是否为0<ul><li><input disabled="" type="checkbox"> 正确</li><li><input checked="" disabled="" type="checkbox"> 错误</li></ul></li><li>当设计模式存在依恋情节的问题时，说明这种设计模式是不可取的。<ul><li><input disabled="" type="checkbox"> 正确</li><li><input checked="" disabled="" type="checkbox"> 错误</li></ul></li><li>多线程操作同一个字符串相加，应采用StringBuilder<ul><li><input disabled="" type="checkbox"> 正确</li><li><input checked="" disabled="" type="checkbox"> 错误</li></ul></li><li>架构和设计都是比较高层抽象的，甚至是保密的。即便如此，在代码层面也应该尽量更多地体现架构和设计方面的信息。这个说法是否正确：<ul><li><input checked="" disabled="" type="checkbox"> 正确</li><li><input disabled="" type="checkbox"> 错误</li></ul></li></ul><h2 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h2><ul><li><p>全局数据对代码的影响不包括：</p><ul><li><input checked="" disabled="" type="checkbox"> A.可扩展性更强</li><li><input disabled="" type="checkbox"> B.对全局数据随意的改变可能引发bug</li><li><input disabled="" type="checkbox"> C.定位困难</li><li><input disabled="" type="checkbox"> D.可以在任何位置进行修改，在使用过程中可能出现意想不到的值</li></ul></li><li><p>下面关于注释，说法错误的是：</p><ul><li><input checked="" disabled="" type="checkbox"> A.并不是所有人都能读懂代码，所以要尽可能详尽的描述代码做了什么</li><li><input disabled="" type="checkbox"> B.当出现长长的注释时，意味着代码难于理解，我们应该考虑重构它</li><li><input disabled="" type="checkbox"> C.函数尽量通过函数名自注释，按需写函数头注释</li><li><input disabled="" type="checkbox"> D.注释应该告诉读者代码的实现意图</li></ul></li><li><p>下列哪类异常不属于敏感异常（）</p><ul><li><input disabled="" type="checkbox"> A.MissingResourceException</li><li><input disabled="" type="checkbox"> B.FileNotFoundException</li><li><input checked="" disabled="" type="checkbox"> C.IOException</li><li><input disabled="" type="checkbox"> D.SQLException</li></ul></li><li><p>关于方法说法错误的是：（）</p><ul><li><input checked="" disabled="" type="checkbox"> A.方法的入参建议当做工作&#x2F;临时变量</li><li><input disabled="" type="checkbox"> B.构造方法如果参数过多，尽量重用</li><li><input disabled="" type="checkbox"> C.避免方法过长，不超过50行（非空非注释）；避免方法的代码块嵌套过深，不要超过4层</li><li><input disabled="" type="checkbox"> D.不用使用标注为@Deprecated的方法</li></ul></li><li><p>关于重构与测试，下面说法中，正确的是</p><ul><li><input disabled="" type="checkbox"> A.测试方法包括单元测试、集成测试、系统测试，重构时我们只需要选择一种即可</li><li><input disabled="" type="checkbox"> B.重构前不管工作量多大都要先补充完善的单元测试，否则不能开始重构</li><li><input checked="" disabled="" type="checkbox"> C.重构时，需要有对应的测试保护，用于验证重构后没有外在行为的变化</li><li><input disabled="" type="checkbox"> D.在单元测试时，务求百分百的条件覆盖，这样才能保证重构没有问题</li></ul></li><li><p>关于变量初始化，说法正确的是（）</p><ul><li><input disabled="" type="checkbox"> A.冗余初始化更安全</li><li><input disabled="" type="checkbox"> B.任何情况变量定义时都要初始化</li><li><input checked="" disabled="" type="checkbox"> C.变量按需初始化</li><li><input disabled="" type="checkbox"> D.可以使用未经初始化的变量</li></ul></li><li><p>以下说法正确的是：</p><ul><li><input checked="" disabled="" type="checkbox"> A.调用SecurityManager执行的安全检查，进行安全检查的方法必须声明为private或final</li><li><input disabled="" type="checkbox"> B.编写自定义类加载器时，需要复写getPermissions()方法时，可以忽略了基类的getPermissions()方法</li><li><input disabled="" type="checkbox"> C.建议使用String存储敏感数据，使用结束后立即赋为空</li><li><input disabled="" type="checkbox"> D.使用java.net.Socket类在不安全的传输通道中传输敏感数据</li></ul></li><li><p>当发现方法的入参是某个对象的一部分时，我们应该：</p><ul><li><input disabled="" type="checkbox"> A.基于最小知道原则，保持原样</li><li><input checked="" disabled="" type="checkbox"> B.基于依赖方向、最小知道原则、参数可维护性等综合考虑，判断用对象替换后的收益和代价，再进行操作</li><li><input disabled="" type="checkbox"> C.直接将整个对象传进去</li></ul></li><li><p>以下符合华为编程规范的是（）</p><ul><li><input disabled="" type="checkbox"> A.public void DRAW()</li><li><input checked="" disabled="" type="checkbox"> B.public void setVisible(boolean)</li><li><input disabled="" type="checkbox"> C.public boolean Finished()</li><li><input disabled="" type="checkbox"> D.public void KeyListener(Listener)</li></ul></li><li><p>下面这一段代码的输出结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        System.out.println(a == b); <span class="hljs-comment">// true or false</span><br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        System.out.println(a == c); <span class="hljs-comment">// true or false</span><br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">321</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-number">321</span>;<br>        System.out.println(d == e);<br>        System.out.println(f == g);<br><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">42L</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span>;<br>        System.out.println(h.equals(j));<br>        System.out.println(h.equals(<span class="hljs-number">42</span>));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> A.true、异常、true、false、true、false</li><li><input disabled="" type="checkbox"> B.true、false、true、false、true、false</li><li><input disabled="" type="checkbox"> C.true、false、true、false、true、true</li><li><input disabled="" type="checkbox"> D.true、异常、true、false、true、true</li></ul></li><li><p>霰弹式修改是指：</p><ul><li><input disabled="" type="checkbox"> A.某个类经常因为不同的原因在不同的方向上发生变化</li><li><input checked="" disabled="" type="checkbox"> B.指的是如果每遇到某种变化，你都必须在许多不同的类内作出许多小修改</li><li><input disabled="" type="checkbox"> C.由于思维发散，设计除了功能不正确的模块</li><li><input disabled="" type="checkbox"> D.两个类功能一致，却又不同的定义</li></ul></li><li><p>关于异常的描述错误的是：（）</p><ul><li><input disabled="" type="checkbox"> A.一个方法不应该抛出超过5个异常，并在Javadoc的@throws标签中记录每个抛出的异常及其条件</li><li><input disabled="" type="checkbox"> B.在catch块中抛出新异常时，避免丢失原始异常信息</li><li><input checked="" disabled="" type="checkbox"> C.FileNotFoundException或IOException异常可以直接抛出</li><li><input disabled="" type="checkbox"> D.不要直接捕获可通过预检查进行消除的RuntimeException，如NullPointerException、IndexOutOfBoundsException等</li></ul></li><li><p>父类的构造方法中调用可能被子类覆写的方法造成的后果可能是：（）</p><ul><li><input disabled="" type="checkbox"> A.父子类方法都无法调用到</li><li><input disabled="" type="checkbox"> B.子类对象还未生成，不可能调用到子类方法</li><li><input disabled="" type="checkbox"> C.只可能调用到当前类的成员方法，没有问题</li><li><input checked="" disabled="" type="checkbox"> D.子类包含的对象还未生成，导致NullPointerException异常</li></ul></li><li><p>如下代码块，在（）时报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br><span class="hljs-comment">// do someting</span><br>temp.add(<span class="hljs-string">&quot;4&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> A.不报错</li><li><input disabled="" type="checkbox"> B.编译</li><li><input checked="" disabled="" type="checkbox"> C.执行</li><li><input disabled="" type="checkbox"> D.加载</li></ul></li><li><p>关于重构时机，下面说法中，错误的是</p><ul><li><input disabled="" type="checkbox"> A.专家review时重构，能够传递经验，改善设计，避免或减少代码持续腐化</li><li><input disabled="" type="checkbox"> B.添加功能时，重构能够使得未来新增特性时更快速、更流畅</li><li><input checked="" disabled="" type="checkbox"> C.在修复错误时，应该聚焦问题本身，不建议重构，可以避免引入新的问题</li></ul></li></ul><h2 id="多选题"><a href="#多选题" class="headerlink" title="多选题"></a>多选题</h2><ul><li><p>关于重复代码，描述正确的有</p><ul><li><input checked="" disabled="" type="checkbox"> A.重复代码难以维护，容易造成修改遗漏</li><li><input checked="" disabled="" type="checkbox"> B.两个相互为兄弟的子类中有重复代码，先提取函数再移到父类中</li><li><input disabled="" type="checkbox"> C.重复代码指完全相同的代码，有差异的不是重复代码</li><li><input checked="" disabled="" type="checkbox"> D.同一个类的两个函数有重复代码，可以考虑使用提取函数手法，提取公共代码</li></ul></li><li><p>消除注释坏味道常见的做法包括：</p><ul><li><input disabled="" type="checkbox"> A.删除所有注释</li><li><input disabled="" type="checkbox"> B.给每一行代码都加上注释</li><li><input checked="" disabled="" type="checkbox"> C.补充必要的注释（public的Javadoc、算法代码等）</li><li><input checked="" disabled="" type="checkbox"> D.通过改名、提炼变量、方法等，消除不必要的注释</li></ul></li><li><p>正确使用异常机制事半功倍，以下说法正确的是（）</p><ul><li><input disabled="" type="checkbox"> A.异常信息仲可以包含敏感信息和个人信息</li><li><input checked="" disabled="" type="checkbox"> B.注释和文档中应该包含所抛出的异常说明</li><li><input checked="" disabled="" type="checkbox"> C.方法抛出的异常，应该与本身的抽象层次相对应</li><li><input disabled="" type="checkbox"> D.异常机制能够承担正常的业务逻辑判断</li></ul></li><li><p>大的Switch case圈复杂度比较高，还会导致代码修改困难，如何优化？</p><ul><li><input checked="" disabled="" type="checkbox"> A.将case条件分组化小，不同的分组提炼成不同的处理函数，设置可以将不同的分组使用不同的变量来表达和处理</li><li><input disabled="" type="checkbox"> B.增加丰富的注释，说明代码该如何修改维护，解决修改困难的问题</li><li><input checked="" disabled="" type="checkbox"> C.将复杂的switch case分支提炼成函数</li><li><input checked="" disabled="" type="checkbox"> D.使用数据驱动表，将switch case逻辑转换成表数据</li><li><input disabled="" type="checkbox"> E.通过定义#define SWITCH switch及#define CASE case解决圈复杂度高的问题</li></ul></li><li><p>以下异常列表那些是属于敏感异常</p><ul><li><input checked="" disabled="" type="checkbox"> A.java.util.ConcurrentModificationException</li><li><input checked="" disabled="" type="checkbox"> B.java.io.FileNotFoundException</li><li><input disabled="" type="checkbox"> C.java.langNullPointerException</li><li><input disabled="" type="checkbox"> D.java.lang.IllegalArgumentException</li><li><input checked="" disabled="" type="checkbox"> E.java.sql.SQLException</li><li><input checked="" disabled="" type="checkbox"> F.java.net.BindException</li></ul></li><li><p>Clean Code之代码可测试时软件发现故障并隔离、定位故障的能力，以及在一定的时间和成本前提下，进行测试设计、测试执行的能力，重点关注如下几个因素：</p><ul><li><input checked="" disabled="" type="checkbox"> A.可定位（问题可定位）</li><li><input checked="" disabled="" type="checkbox"> B.可观测（预期过程与结果可观测）</li><li><input checked="" disabled="" type="checkbox"> C.可隔离（降低测试复杂度）</li><li><input checked="" disabled="" type="checkbox"> D.可控制（测试前置条件可构造）</li></ul></li><li><p>有整数溢出风险的符号是：</p><ul><li><input checked="" disabled="" type="checkbox"> A.+&#x3D;</li><li><input disabled="" type="checkbox"> B.%</li><li><input checked="" disabled="" type="checkbox"> C.java.lang.math.abs()</li><li><input checked="" disabled="" type="checkbox"> D.++</li></ul></li><li><p>关于数据泥团，说法正确的是：</p><ul><li><input checked="" disabled="" type="checkbox"> A.一般情况下，参数较多时出现数据泥团的可能性更高，可优先排查</li><li><input disabled="" type="checkbox"> B.方法参数少于5个时不会存在数据泥团的问题</li><li><input disabled="" type="checkbox"> C.数据泥团是指全部是基本类型的成块数据</li><li><input checked="" disabled="" type="checkbox"> D.通过消除数据泥团，可以减少相同的字段及入参，缩短入参列，简化函数调用</li></ul></li><li><p>下列变量命名不正确的是（）</p><ul><li><input checked="" disabled="" type="checkbox"> A.String customenrname;</li><li><input checked="" disabled="" type="checkbox"> B.List userArray &#x3D; new ArrayList();</li><li><input checked="" disabled="" type="checkbox"> C.boolean isNoError;</li><li><input disabled="" type="checkbox"> D.String xmlData;</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
